/*
 * generated by Xtext 2.26.0
 */
package org.consensus.homodel.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.consensus.homodel.hOModel.Algorithm;
import org.consensus.homodel.hOModel.ArrayVariable;
import org.consensus.homodel.hOModel.Assignment;
import org.consensus.homodel.hOModel.ConjunctiveExpression;
import org.consensus.homodel.hOModel.EqualityExpression;
import org.consensus.homodel.hOModel.Expression;
import org.consensus.homodel.hOModel.Factor;
import org.consensus.homodel.hOModel.HOModelPackage;
import org.consensus.homodel.hOModel.Message;
import org.consensus.homodel.hOModel.NormalVariable;
import org.consensus.homodel.hOModel.RelationalExpression;
import org.consensus.homodel.hOModel.Round;
import org.consensus.homodel.hOModel.RoundList;
import org.consensus.homodel.hOModel.SendPart;
import org.consensus.homodel.hOModel.SimpleExpression;
import org.consensus.homodel.hOModel.Statement;
import org.consensus.homodel.hOModel.StatementList;
import org.consensus.homodel.hOModel.Term;
import org.consensus.homodel.hOModel.VariableDecList;
import org.consensus.homodel.hOModel.VariableNameList;
import org.consensus.homodel.hOModel.VarialbeDeclaration;
import org.consensus.homodel.services.HOModelGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class HOModelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private HOModelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HOModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HOModelPackage.ALGORITHM:
				sequence_Algorithm(context, (Algorithm) semanticObject); 
				return; 
			case HOModelPackage.ARRAY_VARIABLE:
				sequence_ArrayVariable(context, (ArrayVariable) semanticObject); 
				return; 
			case HOModelPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case HOModelPackage.CONJUNCTIVE_EXPRESSION:
				sequence_ConjunctiveExpression(context, (ConjunctiveExpression) semanticObject); 
				return; 
			case HOModelPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case HOModelPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case HOModelPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case HOModelPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case HOModelPackage.NORMAL_VARIABLE:
				sequence_NormalVariable(context, (NormalVariable) semanticObject); 
				return; 
			case HOModelPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case HOModelPackage.ROUND:
				sequence_Round(context, (Round) semanticObject); 
				return; 
			case HOModelPackage.ROUND_LIST:
				sequence_RoundList(context, (RoundList) semanticObject); 
				return; 
			case HOModelPackage.SEND_PART:
				sequence_SendPart(context, (SendPart) semanticObject); 
				return; 
			case HOModelPackage.SIMPLE_EXPRESSION:
				sequence_SimpleExpression(context, (SimpleExpression) semanticObject); 
				return; 
			case HOModelPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case HOModelPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case HOModelPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case HOModelPackage.VARIABLE_DEC_LIST:
				sequence_VariableDecList(context, (VariableDecList) semanticObject); 
				return; 
			case HOModelPackage.VARIABLE_NAME_LIST:
				sequence_VariableNameList(context, (VariableNameList) semanticObject); 
				return; 
			case HOModelPackage.VARIALBE_DECLARATION:
				sequence_VarialbeDeclaration(context, (VarialbeDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Algorithm returns Algorithm
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         variabledeclaration=VarialbeDeclaration 
	 *         domain=Domain? 
	 *         roundlist=RoundList 
	 *         inv=Invariant? 
	 *         uv=Univalence?
	 *     )
	 * </pre>
	 */
	protected void sequence_Algorithm(ISerializationContext context, Algorithm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns ArrayVariable
	 *     ArrayVariable returns ArrayVariable
	 *     Factor returns ArrayVariable
	 *
	 * Constraint:
	 *     (name=ID exp+=Expression)
	 * </pre>
	 */
	protected void sequence_ArrayVariable(ISerializationContext context, ArrayVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (var+=Variable exp+=Expression)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConjunctiveExpression returns ConjunctiveExpression
	 *
	 * Constraint:
	 *     (exp+=EqualityExpression exp+=EqualityExpression*)
	 * </pre>
	 */
	protected void sequence_ConjunctiveExpression(ISerializationContext context, ConjunctiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqualityExpression returns EqualityExpression
	 *
	 * Constraint:
	 *     (exp+=RelationalExpression exp+=RelationalExpression?)
	 * </pre>
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Expression
	 *     Decision returns Expression
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (exp+=ConjunctiveExpression exp+=ConjunctiveExpression*)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     ((exp+=Expression var+=Variable) | exp+=Expression)?
	 * </pre>
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (msg+=ID? msg+=ID*)
	 * </pre>
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns NormalVariable
	 *     NormalVariable returns NormalVariable
	 *     Factor returns NormalVariable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_NormalVariable(ISerializationContext context, NormalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HOModelPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HOModelPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNormalVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationalExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (exp+=SimpleExpression exp+=SimpleExpression?)
	 * </pre>
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RoundList returns RoundList
	 *
	 * Constraint:
	 *     round+=Round+
	 * </pre>
	 */
	protected void sequence_RoundList(ISerializationContext context, RoundList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Round returns Round
	 *
	 * Constraint:
	 *     (send=SendPart transition=TransitionPart)
	 * </pre>
	 */
	protected void sequence_Round(ISerializationContext context, Round semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HOModelPackage.Literals.ROUND__SEND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HOModelPackage.Literals.ROUND__SEND));
			if (transientValues.isValueTransient(semanticObject, HOModelPackage.Literals.ROUND__TRANSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HOModelPackage.Literals.ROUND__TRANSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRoundAccess().getSendSendPartParserRuleCall_3_0(), semanticObject.getSend());
		feeder.accept(grammarAccess.getRoundAccess().getTransitionTransitionPartParserRuleCall_6_0(), semanticObject.getTransition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SendPart returns SendPart
	 *
	 * Constraint:
	 *     ((exp=Expression message1=Message message2=Message?) | message=Message)
	 * </pre>
	 */
	protected void sequence_SendPart(ISerializationContext context, SendPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleExpression returns SimpleExpression
	 *
	 * Constraint:
	 *     (term+=Term term+=Term*)
	 * </pre>
	 */
	protected void sequence_SimpleExpression(ISerializationContext context, SimpleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Domain returns StatementList
	 *     TransitionPart returns StatementList
	 *     Invariant returns StatementList
	 *     Univalence returns StatementList
	 *     StatementList returns StatementList
	 *     Statement returns StatementList
	 *
	 * Constraint:
	 *     statements+=Statement*
	 * </pre>
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     ((var+=Variable exp+=Expression exp+=Expression statement+=Statement) | (exp+=Expression statement+=Statement statement+=Statement?))
	 * </pre>
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (factor+=Factor factor+=Factor*)
	 * </pre>
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDecList returns VariableDecList
	 *
	 * Constraint:
	 *     (type=Type variablenamelist=VariableNameList)
	 * </pre>
	 */
	protected void sequence_VariableDecList(ISerializationContext context, VariableDecList semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HOModelPackage.Literals.VARIABLE_DEC_LIST__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HOModelPackage.Literals.VARIABLE_DEC_LIST__TYPE));
			if (transientValues.isValueTransient(semanticObject, HOModelPackage.Literals.VARIABLE_DEC_LIST__VARIABLENAMELIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HOModelPackage.Literals.VARIABLE_DEC_LIST__VARIABLENAMELIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDecListAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableDecListAccess().getVariablenamelistVariableNameListParserRuleCall_2_0(), semanticObject.getVariablenamelist());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableNameList returns VariableNameList
	 *
	 * Constraint:
	 *     (name+=ID value+=INITIAL_CONST? (name+=ID value+=INITIAL_CONST?)*)
	 * </pre>
	 */
	protected void sequence_VariableNameList(ISerializationContext context, VariableNameList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarialbeDeclaration returns VarialbeDeclaration
	 *
	 * Constraint:
	 *     list+=VariableDecList+
	 * </pre>
	 */
	protected void sequence_VarialbeDeclaration(ISerializationContext context, VarialbeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
